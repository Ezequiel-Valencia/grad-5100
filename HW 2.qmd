---
title: "HW 2"
format: pdf
editor: visual
---

Setup:

```{r}
if (require('HSAUR') == FALSE){
  install.packages('HSAUR')
}
```

### Question 1

a).

```{r}
##########
# Part A #
##########
q1_a_ds <- HSAUR::BtheB$bdi.pre
q1_a_hist <- hist(q1_a_ds, main = "Pre Beat The Blues", ylab = "Frequency", xlab = "Blues Beaten")
q1_a_xvals <- seq(min(q1_a_ds), max(q1_a_ds), 0.01)
q1_a_yvals <- dnorm(q1_a_xvals, mean = mean(q1_a_ds), sd = sd(q1_a_ds))
q1_a_yvals <- q1_a_yvals * diff(q1_a_hist$mids[1:2]) *length(q1_a_ds)
lines(q1_a_xvals, q1_a_yvals)
```

b).

```{r}
##########
# Part B #
##########
par(mfrow = c(1, 2))
ds <- HSAUR::BtheB$bdi.2m
hist <- hist(ds, main = "2M Beat The Blues", ylab = "Frequency", xlab = "Blues Beaten")
xvals <- seq(min(ds, na.rm = TRUE), max(ds, na.rm = TRUE), 1)
yvals <- dnorm(xvals, mean = mean(ds, na.rm = TRUE), sd = sd(ds, na.rm = TRUE))
yvals <- yvals * diff(hist$mids[1:2]) * length(ds)
lines(xvals, yvals)
plot(density(ds, na.rm = TRUE), main = "2M Beat The Blues") # Kernel Density Plot
```

c).

```{r}
##########
# Part C #
##########
par(mfrow = c(1, 2))
hist(HSAUR::BtheB$bdi.2m, main = "2M Beat The Blues", ylab = "Frequency", xlab = "Blues Beaten")
hist(HSAUR::BtheB$bdi.8m, main = "8M Beat The Blues", ylab = "Frequency", xlab = "Blues Beaten")
```

d). You can display all graphics with the partition function as shown below. Another method would be to use the layout function which would also be suitable.

```{r}
##########
# Part D #
##########
par(mfrow = c(2, 3))
hist(HSAUR::BtheB$bdi.pre, main = "Pre Beat The Blues", ylab = "Frequency", xlab = "Blues Beaten")
hist(HSAUR::BtheB$bdi.2m, main = "2M Beat The Blues", ylab = "Frequency", xlab = "Blues Beaten")
hist(HSAUR::BtheB$bdi.4m, main = "4M Beat The Blues", ylab = "Frequency", xlab = "Blues Beaten")
hist(HSAUR::BtheB$bdi.6m, main = "6M Beat The Blues", ylab = "Frequency", xlab = "Blues Beaten")
hist(HSAUR::BtheB$bdi.8m, main = "8M Beat The Blues", ylab = "Frequency", xlab = "Blues Beaten")
```

e).

```{r}
##########
# Part E #
##########
ds <- HSAUR::BtheB
# Because there is no drug type variable, treatment is perceived to be drug type.
pairs(ds[4:8], pch=21, upper.panel = NULL, bg = c('red', "green")[unclass(ds$treatment)]) 
```

### Question 2

a). Via the code below, the data distribution seems to be identical based on the Q-Q plots due to them both having similar shapes. The only difference is at the tail ends of each case having slightly different outcomes, but perhaps with greater sample sizes these anomalies will taper out.

```{r}
##########
# Part A #
##########
par(mfrow = c(1, 2))
set.seed(1234567)
case_1 <- rnorm(n = 100, mean = 20, sd = 2)
set.seed(45301)
case_2 <- rnorm(n = 100, mean = 20, sd = 2)
qqnorm(case_1, main = "Case 1")
qqnorm(case_2, main = "Case 2")
```

b).

```{r}
par(mfrow = c(1, 2))
df <- HSAUR::BtheB
no_drug <- df[df$drug == "No", ]
yes_drug <- df[df$drug == "Yes", ]

boxplot(no_drug$bdi.pre, main="Pre: No Drugs", ylab = "Blues Beaten")
boxplot(yes_drug$bdi.pre, main="Pre: Yes Drugs", ylab = "Blues Beaten")

```

### Question 3

a). It's known within the data set that every rank is unique due to this being an incremental list of the top 2000 companies. Therefore, by ensuring no ranking is in the sampled set twice, we can be sure there is no re-sampling.

```{r}
##########
# Part A #
##########
set.seed(123456) # For reproducability 
x <- Forbes2000
sample_size <- 200
sample_200 <- x[sample(nrow(x), size = sample_size, replace = FALSE), ]
sample_check <- c()
for(rank in sample_200$rank){
  rank_in <- rank %in% sample_check
  if (rank_in){
    rank
    sample_check
    break
  }
  sample_check <- append(sample_check, rank)
}
if (sample_size == length(sample_check)){
  print("No ranks have been repeated.")
} else{
  print("Rank has been repeated")
}

```

b).

```{r}
##########
# Part B #
##########
sales <- sample_200$sales
profits <- sample_200$profits
assests <- sample_200$assets
market_value <- sample_200$marketvalue

cat("---------Means----------\n")
cat("Sales Mean:", mean(sales, na.rm = TRUE), "\nProfits Mean: ", mean(profits, na.rm = TRUE), "\nAssests Mean:", mean(assests, na.rm = TRUE), "\nMarket Value Mean:", mean(market_value, na.rm = TRUE), "\n")

cat("--------Vars-----------\n")
cat("Sales Var:", var(sales, na.rm = TRUE), "\nProfits Var: ", var(profits, na.rm = TRUE), "\nAssests Var:", var(assests, na.rm = TRUE), "\nMarket Value Var:", var(market_value, na.rm = TRUE), "\n")
```

### Question 4

a). Bernoulli's distribution allows for only two values, success(1) or failure(0), so Y can assume either one of those two. It can attribute success with probability of $\pi$, and failure with $1 - \pi$.

b). The probability mass function is as follows: $p(y; \pi) = \pi^y (1 - \pi)^{1-y}$

c).

```{r}
##########
# Part C #
##########
set.seed(1234567)

bern_prob = 0.8
rb <- rbinom(n = 100, size=1, prob=bern_prob)
cat("Mean:", mean(rb), "\nVar:", var(rb))
```

d). The MOM estimate based on the parameter $\pi$ is 0.81 due to the mean calculated from the random sample in part c.





### Question 5

a). The probability is 0.2262191.
```{r}
##########
# Part a #
##########
pii <- 0.05
inv <- 0.95
k <- 0
m <- 5

no_defects <- choose(m, k) * pii^k * inv^{m - k}
1 - no_defects # Its the opposite of no defects, since there will be at least one


```


b). The probability is 0.9774075.

```{r}
##########
# Part B #
##########

pii <- 0.05
inv <- 0.95
k <- 1
m <- 5

one_def <- choose(m, k) * pii^k * inv^{m - k}

pii <- 0.05
inv <- 0.95
k <- 0
m <- 5

no_defects <- choose(m, k) * pii^k * inv^{m - k}

no_defects + one_def # The probability that either 0 or 1 defect is found.

```


c). The probability is 0.7737809.

```{r}
##########
# Part C #
##########

pii <- 0.05
inv <- 0.95
k <- 0
m <- 5

choose(m, k) * pii^k * inv^{m-k}

# 0.95 * .95 * .95 * .95 * .95, aka this

```


d). The probability of exactly 2 defects is 0.02143438.
```{r}
##########
# Part D #
##########

pii <- 0.05
inv <- 0.95
k <- 2
m <- 5

choose(m, k) * pii^k * inv^{m-k}

```


e). The probability that all are defects is 3.125e-07.
```{r}
##########
# Part E #
##########

pii <- 0.05
inv <- 0.95
k <- 5
m <- 5

choose(m, k) * pii^k * inv^{m-k}

# 0.05 * .05 * .05 * .05 * .05 aka this

```


### Question 6

a). The probability is 0.9927049 for at least 2 customers arriving.
```{r}
##########
# Part A #
##########

poisson_func <- function(n_customers){
  y_mean <- 7 # Irrespective of hour
  top <- exp(-1 * y_mean) * y_mean^n_customers # exp means e^{}
  bot <- factorial(n_customers)
  top / bot
}

no_customer <- poisson_func(0)
one_customer <- poisson_func(1)

1 - (no_customer + one_customer) # Since its two or more, that means prob for >= 2, aka 1 - no and one.
```

b). The probability is 0.006383174 for exactly one customer.

```{r}
poisson_func(1)
```

c). The probability of at most 5 customers arriving is 0.3007083.
```{r}
allowed_vals <- poisson_func(5) + poisson_func(4) + poisson_func(3) + poisson_func(2) + poisson_func(1) + poisson_func(0)
allowed_vals
```


d). The probability of no customers is 0.000911882.
```{r}
poisson_func(0)
```


### Question 7

a). Knowing that the Y is roughly equivalent to Uniform(0,$\theta$), the mean of such a distribution for sample Y is $Y = \theta / 2$. Thus, the method of moments estimate for $\theta$ would be $Y * 2 = \theta$ because it is only one parameter that is unknown.


b). When the sample size is increased from 100 to 1000, the MOM estimate deviates more from the actual value, and has a density plot that depicts density is less concentrated around the value 10 for n = 1000.
```{r}

# random sample with n observations in it
# Taken from uniform distribution of interval (0, theta)
# What is the MOM estimate of theta
par(mfrow = c(1, 2))
set.seed(1234567)
samp <- runif(n = 100, min = 0, max = 20)
samp_mean <- mean(samp)
plot(density(samp))
cat("Mean(n = 100):", samp_mean, "MOM Estimate:", samp_mean * 2, "\n")

samp <- runif(n = 1000, min = 0, max = 20)
samp_mean <- mean(samp)
plot(density(samp))
cat("Mean(n = 1000):", samp_mean, "MOM Estimate:", samp_mean * 2)
```











